this is a (not so) short list of shit we need to know for this project.
* The assembly language is a specific variant for this course.

There are 3 stages of creating and opening a code in a computer:
1. Compiling
2. Linking
3. Loading
We're only compiling the code.

this is an "imaginary" computer, it includes:
1. CPU
2. Registers
3. RAM
* Some of the ram will be used for stack.

Registers: 
1. The computer has 8 general registers:
        r0, r1, r2, r3, r4, r5, r6, r7
    The size of each register is 24 bits.
        The least important one is bit 0 -> most important is bit 23.
* the register name will always be written with a lowercase 'r'.

2. There is another register called PSW (Program Status Word):
    The PSW includes flags that show the status of the cpu at any given moment.

RAM:
1.  The size of the ram is 2^21 cells.
        The cell addresses are 0 to 2^21-1.

        The size of each cell is 24 bits (reminds you of something?)
        The bits inside each cell are numbered in the same way as the registers.
        
    * A cell in the memory is also called "word".

This computer only works with FULL positive or negative numbers.
The arithmetics is done in the 2's complement method. (I have no clue what is the meaning of that)
The computer has support for ascii characters.

The instruction:
    Each instruction consists of an operation and 0 - 2 operands (arguments).
    You can have a source operand and destination operand.

    Each instruction is coded to info-words (wtf?), 
    from 1 to a max of 3 words, based on the addressing method of the operand. 

The BITs for an instruction:
# opcode
Bits 18-23:
    These bits contain the "opcode", the code used to distinguish between operations.
Bits 7-3:
    These bits contain the funct.
    The {funct} is used when the opcode is the same for different operations. (opcodes 2,5,9).
    The {funct} will contain a unique value for each operation from those operations (2,5,9).
    If the opcode is only used for one operation, these bits will be 0.
# Source operand
Bits 17-16:
    These bits contain the number of the addressing method of the source operand.
    if the instruction has no source operand, these bits will be 0.
Bits 15-13:
    These bits contain the number of register of the source operand incase it's a register.
    otherwise they will be 0. (if the source isn't a register)
# Destination operand
Bits 12-11:
    These bits contain the addressing method of the destination operand.
    if the instruction has no destination operand, these bits will be 0.
Bits 10-8:
    These bits contain the number of register of the destination operand incase it's a register.
    otherwise they will be 0. (if the destination isn't a register)
#info-words
Bits 2-0:
    These bits are (A,R,E) -> used for addressing methods I think?
    in the first word of each instruction, A = 1, R = 0, E = 0.


The operations:
    We have 16 built in operations, even though you can code more.
    Each operation has a name (operation), a code (op-code), and a function (funct).

    A cheat code appeares later in this file, explaining each operation.

    Operation  | Funct | Op-Code
    -----------------------------
        mov    |       |   0
        cmp    |       |   1
        add    |   1   |   2
        sub    |   2   |   2
        lea    |       |   4
        clr    |   1   |   5
        not    |   2   |   5
        inc    |   3   |   5
        dec    |   4   |   5
        jmp    |   1   |   9
        bne    |   2   |   9
        jsr    |   3   |   9
        red    |       |   12
        prn    |       |   13
        rts    |       |   14
        stop   |       |   15


MY FAVOURITE PART!!!! (I have no fucking clue what I'm doing)
Addressing Methods:
    In our assembly language there are 4 addressing methods, marked with numbers (0,1,2,3).
    The usage of some of the methods requires extra information-words from the instruction.

    Each operand of an instruction requries [AT LEAST] one extra info-word. 

    If the instruction has 2 operands that requires and extra info-word, 
    the info-word of the source operand will appear before the one for the destination

    Each extra info-word is coded using one of 3 types (A,R,E). 
    They explain the type of coding for the word, and they will be ON (1) if the word is given with that type.

    BIT 2 (A): 
        A, or Absolute, means the coding of the word requires no change during the loading and linking stages.
    BIT 1 (R):
        R, or Relocatable, means the word is a pointer that can be changed, it does require changes in the other stages.
    BIT 0 (E):
        E, or External, means the word is an external pointer, it does require changes in the other stages.
    
The info-word, is an extra to the instruction, it includes more info needed for the instruction
it uses exactly 21 bits out of the 24, saved in bits 23-3. bits 2-0 are used for (A,R,E).

our addressing methods are:
    0. Immediate addressing:
        The operand is included in the instruction itself.
        This method is faster because there is no need to read the memory for the value of the operand.
        
        The operand is 21 bits in length, saved in bits 23-3.
        BIT 2 (A) = 1
        BIT 1 (R) = 0
        BIT 0 (E) = 0

        The operand will start with '#', afterwards there will be an integer.

        Example: "mov #-1, r2"
            The source operand is -1, destination operand is r2.
            This instruction writes -1 into register r2.
    
    1. Direct addressing:
        The info-word is a memory address to the operand.
        This method is simple, as it provides direct memory access to the operand.

        The address is 21 bits in length, saved in bits 23-3.
        The address has no sign (+/-).

        BITs 2-0 are depended on the address:
            * If the address represents a line in the same file (internal address) 
                BIT 1 (R) = 1, BITs 2 0 (A E) = 0
            * If the address represents a line in a different file (external address)
                BIT 0 (E) = 1, BITs 2 1 (A R) = 0
        
        The operand is a label that has been declared / will be declared in the file.
        The label represents a memory address with a name (WOAH THAT'S A VARIABLE)

        The declaration is done in this format:
        {name}: .{data/string/entry/extern} {value}

        for example:
            # Create var x, with value of 23.
            x: .data 23
            # Decrease the value of x by 1.
            dec x
        another example:
            # This will jump (sort of loop) to the line where next is declared.
            jmp next

            # the address for next is coded in bits 23-3 of the word.
    
    2. Relative addressing:
        This method is only relevant for instructions that performs a jump to a different instruction.
        A.K.A only [jmp, bne, jsr].
        This method CANNOT be used with other instructions.

        in this method, the info word contains the length of the jump - from the current instruction to the next one (the one after the jump).
        The length of the jump is represented by a signed integer with the length of 21 bits, saved in bits 23-3.
        This length will be negative if the destination instruction comes before the source.

        BITs 2-0:
            BIT 2 (A) = 1, BITs 1 0 (R E) = 0.

        The operand will start with & and a label: &next for example.
        The label represents an instruction in the source file, you can't use labels from other files.

    3. Direct Register addressing:
        This method only has an operand: no info-words.
        The operand is the name of a register.

        example:
            clr r1
            # zero's (clears) the register r1.


Instruction cheat list:
    This list has 3 parts, split by the amount of operands each instruction requires.

    First group (2 operands):
        opcode| funct| name|                                explaination                                   | example
        -----------------------------------------------------------------------------------------------------------------------------------------------------------
           0  |      | mov | copy the source to the destination                                            | mov A, r1      # Copies A into r1 
           1  |      | cmp | compares the two operands. if equal flag Z inside register PSW is set         | cmp A, r1      # PSW = 1 if equal
           2  |  1   | add | adds the source to the destination.                                           | add A, r0      # r0 = r0 + A
           2  |  2   | sub | subtructs the source from the destination.                                    | sub A, r1      # r1 = r1 - A
           4  |      | lea | load effective address. loads the address from the source to the destination  | lea HELLO, r1  # the address for hello is set into r1.
        -----------------------------------------------------------------------------------------------------------------------------------------------------------
    
    Second group (1 operands):
        opcode| funct| name|                                explaination                                       | example
        -----------------------------------------------------------------------------------------------------------------------------------------------------------
           5  |  1   | clr | clears the operand                                                                | clr r2       # r2 = 0 
           5  |  2   | not | flips each bit in the operand (1 -> 0 | 0 -> 1)                                   | not r2       # every bit inside r2 is flipped
           5  |  3   | inc | increases the operand by 1                                                        | inc r2       # r2 += 1
           5  |  4   | dec | decreases the operand by 1                                                        | dec r2       # r2 -= 1
           9  |  1   | jmp | jumps (skips) to the instruction at the operand, continuing from the operand      | jmp &Line    # makes it so the next instruction is line
           9  |  2   | bne | branch if no equal, only jumps if the Z flag is 0                                 | bne Line     # if flag Z inside PSW is 0 (if a previous cmp failed) jumps to line
           9  |  3   | jsr | Jump to Subroutine, jumps but saves the previous location, letting you jump back  | jsr SUBR     # jumps to SUBR and saves the current line (+2) into the stack
           12 |      | red | reads a character from stdin to the operand                                       | red r1       # Saves the next ascii char read into r1 
           13 |      | prn | prints the character saved in the operand                                         | prn r1       # prints the character in r1 to stdout
        -----------------------------------------------------------------------------------------------------------------------------------------------------------
    
    Third group (0 operands):
        In these instructions there are no operands - BITs 17-8 should be cleared (0).

        opcode| funct| name |                                explaination                                                  | example
        ------------------------------------------------------------------------------------------------------------------------------------------------------------
          14  |      | rts  | returns from the subroutine back to normal. the location for "normal" should be in the stack | rts   # moves back to the line
          15  |      | stop | stops the program                                                                            | stop  # Immediately stops the program
        ------------------------------------------------------------------------------------------------------------------------------------------------------------

The assembly language structure:
* A program written in assembly is built from macroes and statements.

Macroes:
    Macroes are code snippets that contain statements.
    In a program you can define macroes and use them in different places in the program.
    The use of a macro will "paste" the code snippet instead of the macro name.

    Defining a macro:
    #   defining a macro named a_mc
        mcro a_mc
          inc r2
          mov A,r1
        mcroend
    
    using a macro:
        (code)
        .
        .
        a_mc
        .
        .
        (code)
    
Assumptions and guidelines about macroes:
* There are no nested macroes (There's no need to check)
* The user cannot use the name of an instruction for a macro (Will return an error)
* We can assume every macro is properly closed with mcroend (There's no need to check)
* Defining the macro will always be before it's usage (There's no need to check)
* The pre-compiler needs to create a file with the macroes pasted in the correct locations.

to sum up, we need to check:
1. A valid name (not the name of an instruction)
2. There are no extra characters in the definition.

If an error was found during the macro check, we need to stop and report the error to the user, and move on to the next file.

Statements:
d