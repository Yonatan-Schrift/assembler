this is a (not so) short list of shit we need to know for this project.
* The assembly language is a specific variant for this course.

There are 3 stages of creating and opening a code in a computer:
1. Compiling
2. Linking
3. Loading
We're only compiling the code.

this is an "imaginary" computer, it includes:
1. CPU
2. Registers
3. RAM
* Some of the ram will be used for stack.

Registers: 
1. The computer has 8 general registers:
        r0, r1, r2, r3, r4, r5, r6, r7
    The size of each register is 24 bits.
        The least important one is bit 0 -> most important is bit 23.
* the register name will always be written with a lowercase 'r'.

2. There is another register called PSW (Program Status Word):
    The PSW includes flags that show the status of the cpu at any given moment.

RAM:
1.  The size of the ram is 2^21 cells.
        The cell addresses are 0 to 2^21-1.

        The size of each cell is 24 bits (reminds you of something?)
        The bits inside each cell are numbered in the same way as the registers.
        
    * A cell in the memory is also called "word".

This computer only works with FULL positive or negative numbers.
The arithmetics is done in the 2's complement method. (I have no clue what is the meaning of that)
The computer has support for ascii characters.

The instruction:
    Each instruction consists of an operation and 0 - 2 operands (arguments).
    You can have a source operand and destination operand.

    Each instruction is coded to memory words (wtf?), 
    from 1 to a max of 3 words, based on the addressing method of the operand. 

The BITs for an instruction:
# opcode
Bits 18-23:
    These bits contain the "opcode", the code used to distinguish between operations.
Bits 7-3:
    These bits contain the funct.
    The {funct} is used when the opcode is the same for different operations. (opcodes 2,5,9).
    The {funct} will contain a unique value for each operation from those operations (2,5,9).
    If the opcode is only used for one operation, these bits will be 0.
# Source operand
Bits 17-16:
    These bits contain the number of the addressing method of the source operand.
    if the instruction has no source operand, these bits will be 0.
Bits 15-13:
    These bits contain the number of register of the source operand incase it's a register.
    otherwise they will be 0. (if the source isn't a register)
# Destination operand
Bits 12-11:
    These bits contain the addressing method of the destination operand.
    if the instruction has no destination operand, these bits will be 0.
Bits 10-8:
    These bits contain the number of register of the destination operand incase it's a register.
    otherwise they will be 0. (if the destination isn't a register)

Bits 2-0:
    These bits are (A,R,E) -> used for addressing methods I think?
    in the first word of each instruction, A = 1, R = 0, E = 0.


The operations:
    We have 16 built in operations, even though you can code more.
    Each operation has a name (operation), a code (op-code), and a function (funct).

    Operation  | Funct | Op-Code
    -----------------------------
        mov    |       |   0
        cmp    |       |   1
        add    |   1   |   2
        sub    |   2   |   2
        lea    |       |   4
        clr    |   1   |   5
        not    |   2   |   5
        inc    |   3   |   5
        dec    |   4   |   5
        jmp    |   1   |   9
        bne    |   2   |   9
        jsr    |   3   |   9
        red    |       |   12
        prn    |       |   13
        rts    |       |   14
        stop   |       |   15


MY FAVOURITE PART!!!! (I have no fucking clue what I'm doing)
Addressing Methods:
